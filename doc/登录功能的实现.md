# SpringBoot与vue实现登录功能



## 基本思路：

1、使用SpringBoot + shiro实现后端的登录验证、权限管理

2、通过使用token传输给前端保持登录状态。

3、前端vue通过路由过滤验证是否存在token判断，如果浏览器中不存在token则跳转到登录页面。

4、后端使用过滤器判断token是否过期，如果前端发送过来的请求不包含token，并且请求的是包含登录权限的页面，则后端将会返回403（无权限）给前端，前端将会跳转到登录页面进行登录。

5、后端使用jwt封装token，并且通过jwt验证token是否是正确的。



## 代码的实现：

1. 继承**`AuthenticationToken`** 实现自己的token类`JwtToken`，用来替换shiro中自带的token。

2. `TokenUtil`类，封装了`jwt(json web token)`中token的生成与验证功能，可以通过token获取封装在其中的用户名等信息。

3. 增加Shiro过滤器`JwtFilter`拓展**`AccessControlFilter`**，需要在注册配置文件中注册这个过滤器。重新以下方法：
   1.  **`isAccessAllowed`**： 判断是否携带了正确的token，如果返回true，表示shiro允许访问url，如果为false，表示shiro才会根据`onAccessDenied`的方法的返回值决定是否允许访问url。
   2. **`onAccessDenied`**：是没有携带`jwtToken`的时候对账号密码登录，登录成功运行访问，登录失败就拒绝访问。
4. 实现自定义的`JwtRealm`继承**`AuthorizingRealm`** 对登录进行认证。重写以下的方法：
   1. **`supports`**：表示这个Realm是专门验证jwtToken，不负责验证其他的token。
   2. **`doGetAuthorizationInfo`**：授权验证，对shiro中配置的权限进行验证
   3. **`doGetAuthenticationInfo`**：认证，token值为`JwtFilter`过滤器中传过来的token值。
5. 配置Shiro，需要关闭Session，默认调用自定义的Subject方法，关闭ShiroDao等，注册JWTFilter，配置过滤的网址和权限等。



### 1、实现jwtToken

```java

public class JwtToken implements AuthenticationToken {

    private String token;

    public JwtToken(String token) {
        this.token = token;
    }

    @Override
    public Object getPrincipal() {
        return token;
    }

    @Override
    public Object getCredentials() {
        return token;
    }
}
```





### 2、实现TokenUtil工具类

```java

public class TokenUtil {

    // token的秘钥
    private static String TOKEN_SECRET = "secret";

    // token的header
    public static String TOKEN_HEADER = "token";

    // token过期的时间
    public static long EXPIRE_TIME =  2 * 60 * 1000L;

    /**
     * 获取到加密的token
     *
     * @param id       用户id
     * @param username username
     * @return
     */
    public static String getToken( String username) {
        // 创建jwt
        return JWT.create()
                .withSubject(username)
                // 设置内容信息

                .withClaim("username", username)
                // 设置token的开启时间
                .withIssuedAt(new Date())
                // 设置token的过期时间
                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRE_TIME))
                // 设置token的加密方式
                .sign(Algorithm.HMAC256(TOKEN_SECRET));

    }

    /**
     * 验证token是否正确
     *
     * @param token
     * @return
     */
    public static boolean verifyToken(String token) {
        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(TOKEN_SECRET))
                .build();

        try {
            DecodedJWT jwt = jwtVerifier.verify(token);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("token 验证失败");
        }
        return false;
    }

    /**
     * 获取token中的用户username
     *
     * @param token
     * @return
     */
    public static String getTokenUsername(String token) {
        try {
            DecodedJWT jwt = JWT.decode(token);
            return jwt.getClaim("username").asString();
        } catch (JWTDecodeException e) {
            return null;
        }
    }

    /**
     * 根据claim名称获取值
     *
     * @param token
     * @param name
     * @return
     */
    public static String getClaimByName(String token, String name) {
        try {
            DecodedJWT jwt = JWT.decode(token);
            return jwt.getClaim(name).asString();
        } catch (JWTDecodeException e) {
            return null;
        }
    }

    /**
     * 判断token是否过期
     * @return
     */
    public static boolean isTokenExpired(String token) {
        DecodedJWT jwt = JWT.decode(token);
        Date expiresAt = jwt.getExpiresAt();
        System.out.println(expiresAt);
        boolean flag = expiresAt.before(new Date());
        System.out.println(flag);
        return  flag;
    }
}
```



### 3、实现自定义的JwtFilter

```java

@Component
public class JwtFilter extends AuthenticatingFilter {
    private final Logger logger = LoggerFactory.getLogger(TokenFilter.class);


    /**
     * 实现登录，创建自己的token
     */
    @Override
    protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception {
        // 获取token
        HttpServletRequest servletRequest = (HttpServletRequest) request;
        String token = servletRequest.getHeader(TokenUtil.TOKEN_HEADER);
        logger.info("=============createToken {}==================", token);

        if(token == null || "".equals(token)){
            return null;
        }

        return new JwtToken(token);
    }

    /**
     * 判断访问是否被允许，
     *      如果返回true，则表示不需要经过shiro验证，
     *      返回false，则需要进入onAccessDenied中进行判断
     * @param request
     * @param response
     * @param mappedValue
     * @return
     */
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {
//        System.out.println("===========isAccessAllowed==================");
        logger.info("================ isAccessAllowed ===============");

        // 返回false，让其全部通过onAccessDenied进行验证
        return false;
    }

    /**
     * 拦截校验，当头部没有Authorization时候，我们直接通过，不需要自动登录；
     * 当带有的时候，首先我们校验jwt的有效性，没问题我们就直接执行executeLogin方法实现自动登录
     */
    @Override
    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {
        HttpServletRequest servletRequest = (HttpServletRequest) request;
        String token = servletRequest.getHeader(TokenUtil.TOKEN_HEADER);
        JwtToken jwtToken = new JwtToken(token);
        System.out.println("token = " + token);
        logger.info("================onAccessDenied {}=====================", token);


        try {

        getSubject(request, response).login(jwtToken);
        }catch (Exception e){
            e.printStackTrace();
            onLoginFailure((AuthenticationToken) jwtToken, (AuthenticationException) e, request, response);
        }

        return true;
//       return executeLogin(request, response);
    }

    /**
     * onLoginFailure：登录异常时候进入的方法，我们直接把异常信息封装然后抛出
     */
    @Override
    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {
        logger.info("=============onLoginFailure ===================");
        // 处理登录失败的异常
        HttpServletResponse servletResponse = (HttpServletResponse) response;
        System.out.println("========onLoginFailure========");
        try {
            Throwable throwable = e.getCause() == null ? e:e.getCause();
            String json = JSON.toJSONString(throwable);
            servletResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

            ServletOutputStream outputStream = response.getOutputStream();
            outputStream.write(json.getBytes(StandardCharsets.UTF_8));
            outputStream.flush();

        }catch (Exception ex){
            ex.printStackTrace();
        }
        return super.onLoginFailure(token, e, request, response);
    }

}

```





### 4、实现自定义的Realm

```java

public class MyRealm extends AuthorizingRealm {
    private final Logger logger = LoggerFactory.getLogger(MyRealm.class);

    /**
     * 表示该Realm该过滤的是哪种token，只负责验证JwtToken，不负责验证其他的token
     * @param token
     * @return
     */
    @Override
    public boolean supports(AuthenticationToken token) {
        return token instanceof JwtToken;
    }

    // 用户的权限验证
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        logger.info("===========doGetAuthorizationInfo============");

        return null;
    }

    // 用户登录验证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        logger.info("==============doGetAuthenticationInfo===========");
        // 将token转换为UsernamePasswordToken
        JwtToken jwtToken = (JwtToken) authenticationToken;
        String token = (String) jwtToken.getPrincipal();
        System.out.println("==============" + jwtToken);
//        String username = TokenUtil.getTokenUsername(token);


        // 将对token的判断放在这里
        if(token == null){
            logger.info("=============== token is null ===========");
            throw new NullPointerException("jwtToken 不允许为空");
        }

//         验证token的真实性
        if(!TokenUtil.verifyToken(token)){
            System.out.println("=====token验证失败========");
            throw new UnknownAccountException("token验证失败");
        }

        if(TokenUtil.isTokenExpired(token)){
            System.out.println("=======token失效，请重新登录=======");
            throw new ExpiredCredentialsException("token已失效，请重新登录！");
        }

        String username = TokenUtil.getTokenUsername(token);
        logger.info("使用token登录{}", username);
        return new SimpleAuthenticationInfo(token, token, getName());
    }
}

```



### 5、配置Shiro

因为使用的是token进行管理的登录权限，不使用session，需要将其关闭，不然会造成session污染错误。

```java
public class JwtDefaultSubjectFactory extends DefaultWebSubjectFactory {

    @Override
    public Subject createSubject(SubjectContext context) {

        // 保护创建session
        context.setSessionCreationEnabled(false);
        return super.createSubject(context);
    }
}
```



Shiro的配置

```java

@Configuration
public class ShiroConfig {
    @Bean
    public MyRealm myRealm(){
        return new MyRealm();
    }

    @Bean
    public SubjectFactory subjectFactory(){
        return new JwtDefaultSubjectFactory();
    }

    @Bean
    public DefaultWebSecurityManager manager(@Qualifier("myRealm") MyRealm myRealm){
        // 设置默认的web安全管理器
        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();
        manager.setRealm(myRealm);

        // 关闭 ShiroDAO 功能
        DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO();
        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator();
        // 不需要将 Shiro Session 中的东西存到任何地方（包括 Http Session 中）
        defaultSessionStorageEvaluator.setSessionStorageEnabled(false);
        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);
        manager.setSubjectDAO(subjectDAO);
//        禁止Subject的getSession方法
        manager.setSubjectFactory(subjectFactory());

        return manager;
    }

    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier("manager") DefaultWebSecurityManager manager){
        // 设置Shiro的过滤器链Bean对象
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        bean.setSecurityManager(manager);

        Map<String, Filter> filters = new HashMap<>();
        filters.put("jwt", new TokenFilter());
        bean.setFilters(filters);

        // 设置shiro的过滤链，放在前面的首先进行过滤
        Map<String, String> map= new HashMap<>();
        map.put("/main", "anon");
        map.put("/login", "anon");
        map.put("/logout", "anon");
        map.put("/**", "jwt");

        bean.setFilterChainDefinitionMap(map);

        // 设置登录页面
        bean.setLoginUrl("/login");
        // 设置未授权页面
        bean.setUnauthorizedUrl("/unanthu");
        bean.setSuccessUrl("/main.html");

        return bean;
    }
    
    // 开启Session注解
     @Bean
    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {
        return new LifecycleBeanPostProcessor();
    }
 
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
}

```





